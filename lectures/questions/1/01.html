\begin{document}

Group the following sentences with the suitable relations: (syntax, semantics, pragmatics)
\begin{itemize}
\item Kotlin provides infix notation with which we can skip using a dot and parentheses across the parameter
\item Infix operator allows to call a function with the class object and the parameter
\end{itemize}


\section{Syntax}

Select true statements:

\begin{itemize}
% True
\item From the lexical point language can be seen as a sequence of tokens
\item Expression consist of tokens
% False
\item Tokens consist of expressions
\item Similarly to natural languages, programming can contain unresolvable ambiguities.
\end{itemize}
<ul>
  <li> Syntax~--- relations between the signs of sign system themselves.</li>
  <li> Semantics~--- relations between a sign system and objects.</li>
  <li> Pragmatics~--- relations between a sign system and a person.</li>
  <ul>
    Select requirements which are usually used to design a programming language:
    \begin{itemize}
    % True:
    \item unambiguity
    \item allowing for efficient analysis

    % False
    \item allowing for easy verbal comprehension
    \item ambiguity
    \end{itemize}


    \section{Semantics}

    Select true statements:
    \begin{itemize}
    % True
    \item We can always formally specify the semantics of a programming language
    \item Compilers are usually evolve through time
    % False
    \item We can always formally specify the semantics of a natural language
    \item Compilers are usually written "once and for all"
    \item The compilers are the only instrument that requires knowledge of the language semantics
    \end{itemize}

    Write the word for the code which is designed to be incomprehensible:
    obfuscated

    \section{The Essence of Translation}
    % Easy
    What is the syntactic transformation of programs in one language into (equivalent) programs into another:
    (translation)

    Match the language with its

    \begin{itemize}
    \item The language in which programmer writes the code (source)
    \item The language which is the result of the compilation process (target)
    \item The language in which compiler is written (implementation)
    \end{itemize}

    % Medium

    Kotlin compiler (https://github.com/JetBrains/kotlin) allows compilation into multiple platforms.
    Match the language with its type (source, target, implementation)
    \begin{itemize}
    \item Kotlin (source, implementation)
    \item JavaScript (target)
    \item JVM byte-code (target)
    \end{itemize}


    \section{Translation Subspecies}

    Match the translator type with its description:
    \begin{itemize}
    \item From TypeScript to JavaScript (transpiler)
    \item From Java code to JVM bytecode (compiler)
    \item From assembler bytecode to C code (decompiler)
    \item From x86 to ARM assembly
    \end{itemize}

    Select true statements:
    \begin{itemize}

    \end{itemize}

    \section{Environments, Runtime Support and Cross-Compilation}

    % Easy
    % What is runtime support library?
    % What is a standard library?


    What are the characteristics of runtime support library?
    % True:
    - Contains some of the programming language constructs
    - Includes memory management
    - Includes synchronization primitive
    % False
    - Included into the compiler itself
    - Can be accessed directly by the programmer, writing in source language


    % Medium
    % Select all runtime support libraries from the list:

    % Select all standard libraries from the list:


    1.
    <p>In this step you will create an abstract syntax tree from the given source code.
      The source code is written in the language of expressions.
    </p>
    This language consists of numbers and binary expressions, but later we'll extend it.
    For now we will have five binary operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,
    <code>^</code>
    D</code>ifferent operators have different associativity.
    For example, operator <code>^</code> have right associativity.
    The expression <code>(5 ^ 4 ^ 3 ^ 2)</code> should be calculated as <code>5 ^ (4 ^ (3 ^ 2))</code>,
    while division operator <code>/</code> have left associativity, and <code>6 / 3 / 2</code> should be calculated as
    <code>(6 / 3) /2</code>
    Also different operators have different priority.
    For example, <code>10 + 20 * 30</code> should be read as <code>10 + (20 * 30)</code>


    Input: 10 + 20 + 30 * 40
    Output: BINOP("+", 10, BINOP("+", 20, BINOP ("*", 30, 40)))

    2. In this step you will create an interpreter for an abstract syntax tree.
    You should interpret the program in the form of AST and print the result.

    Input: BINOP("+", 10, BINOP("+", 20, BINOP ("*", 30, 40)))
    Output: 1230



